#!/bin/bash

############################ set terminal config ###############################

setterm -cursor off	# make the cursor disappear
stty -echo # make input characters desappear

############################# signal handling ##################################

function exit_snake()
{
	tput clear
	echo "snake: exiting..."
	setterm -cursor on
	stty echo
	exit 1
}


# TODO: uncomment this when the script is finished
#SIG=0
#while [ $SIG -lt 30 ]; do
#	trap "exit_snake" $SIG
#	((SIG++))
#done


######################### random coordinate generator ##########################

function rand_coord()
{
	return $((RANDOM%$1))
}

################################### tmove ######################################

function tputxy()
{
	local Y=$3
	local X=$2
	((Y++))
	((X++))
	echo -en "\e[${Y};${X}H${1}"
	tput ho
}

################################## move_block ##################################

function move_block() 
{
	local BLOCK="$1"
	local DIRECTION=$2
	local S_X=$(echo $BLOCK | cut -d\  -f1)
	local S_Y=$(echo $BLOCK | cut -d\  -f2)
	case $DIRECTION in
		$UP)	((S_Y--));;
		$DOWN)	((S_Y++));;
		$LEFT)	((S_X--));;
		$RIGHT)	((S_X++));;
	esac
	echo "$S_X $S_Y"
}

################################## update_tail #################################

function update_tail()
{
	local TAIL_X=$(echo $1 | cut -d\  -f1)
	local TAIL_Y=$(echo $1 | cut -d\  -f2)
	local NEXT_X=$(echo $2 | cut -d\  -f1)
	local NEXT_Y=$(echo $2 | cut -d\  -f2)
	local DIFF_X=$((NEXT_X-TAIL_X))
	local DIFF_Y=$((NEXT_Y-TAIL_Y))

	if [ $DIFF_X -eq 0 ]; then
		if [ $DIFF_Y -gt 1 ];then
			local Y=$((TAIL_Y+1))
			echo "$TAIL_X $Y"
			return 0
		elif [ $DIFF_Y -lt -1 ]; then
			local Y=$((TAIL_Y-1))
			echo "$TAIL_X $Y"
			return 0
		else
			echo "$1"
			return 1
		fi
	elif [ $DIFF_Y -eq 0 ]; then
		if [ $DIFF_X -gt 1 ];then
			local X=$((TAIL_X+1))
			echo "$X $TAIL_Y"
			return 0
		elif [ $DIFF_X -lt -1 ]; then
			local X=$((TAIL_X-1))
			echo "$X $TAIL_Y"
			return 0
		else
			echo "$1"
			return 1
		fi
	fi
}

################################# collide_test #################################

function collide_test()
{
	local SNAKE=$1
	local X=$2
	local Y=$3

	#compare the snake coordinates to X and Y
}

########################### get terminal dimensions ############################

tput clear
tput cols > tmp
read COLS < tmp
tput lines > tmp
read LINES < tmp
rm tmp
#echo "Columns: $COLS" #DEBUG
#echo "Lines: $LINES" #DEBUG

############################# set game variables ###############################

UP=-2
DOWN=-1
LEFT=1
RIGHT=2
DIR=0

HEAD=-1
TAIL=0
declare -a SNAKE
rand_coord $COLS
SNAKE+=("$?")
rand_coord $LINES
SNAKE[$HEAD]="${SNAKE[$HEAD]} $?"
LENGTH=1
#echo "SNAKE[$HEAD]=${SNAKE[$HEAD]}" #DEBUG
ADD_BLOCKS=0

CHERRY="${SNAKE[$HEAD]}"
while [ "$CHERRY" == "${SNAKE[$HEAD]}" ]; do
	rand_coord $COLS
	CHERRY="$?"
	rand_coord $LINES
	CHERRY="$CHERRY $?"
done
#echo "CHERRY=$CHERRY" #DEBUG

################################# initiate game ################################

tputxy "#" ${SNAKE[$HEAD]}
tputxy "*" $CHERRY

INPUT=""
escape_char=$(printf "\u1b")
while [ $DIR -eq 0 ]; do
	read -sn3 INPUT # get 3 charaters
	case $INPUT in
		"$escape_char[A") DIR=$UP 		;;
		"$escape_char[B") DIR=$DOWN 	;;
		"$escape_char[D") DIR=$LEFT 	;;
		"$escape_char[C") DIR=$RIGHT	;;
	esac
done
OLDIR=$DIR

################################## input loop ##################################

while [ 42 ]; do
	##get input
	DIR_INPUT=$DIR
	read -sn1 -t 0.1 INPUT # get 1 character
	if [ "$INPUT" == "$escape_char" ]; then
    	read -sn2 -t 0.0001 INPUT # read 2 more chars
		case $INPUT in
			'[A') DIR_INPUT=$UP 	;;
			'[B') DIR_INPUT=$DOWN 	;;
			'[D') DIR_INPUT=$LEFT 	;;
			'[C') DIR_INPUT=$RIGHT	;;
		esac
	elif [ "$INPUT" == "q" ]; then
		echo "quitting..."
		sleep 1
		break
	fi

	##set direction
	OLDIR=$DIR
	if [ $DIR -lt 0 -a $DIR_INPUT -gt 0 ]; then
		DIR=$DIR_INPUT
	elif [ $DIR -gt 0 -a $DIR_INPUT -lt 0 ]; then
		DIR=$DIR_INPUT
	fi

	##move snake
	NEW_HEAD=$(move_block "${SNAKE[$HEAD]}" $DIR)
	OLD_TAIL="${SNAKE[$TAIL]}"
	tputxy "SNAKE[HEAD]=$NEW_HEAD" 0 7 #DEBUG
	tputxy "SNAKE[TAIL]=$NEW_HEAD" 0 8 #DEBUG
	if [ "$NEW_HEAD" == "$CHERRY" ]; then # check if the snake is on the cherry
		ADD_BLOCKS=4
		# TODO: re-generate the CHERRY coordinates while it collides with the snake
		rand_coord $COLS
		CHERRY="$?"
		rand_coord $LINES
		CHERRY="$CHERRY $?"
		tputxy "CHERRY=$CHERRY" 0 9 #DEBUG
		tputxy "*" $CHERRY
	fi
	if [ $ADD_BLOCKS -gt 0 ]; then
		if [ $LENGTH -eq 1 -o $DIR -ne $OLDIR ]; then
			SNAKE+=("$NEW_HEAD")
		else
			SNAKE[$HEAD]="$NEW_HEAD"
		fi
		((LENGTH++))
		((ADD_BLOCKS--))
		OLD_TAIL=""
	else
		if [ $LENGTH -gt 1 ]; then
			# move the tail
			NEW_TAIL=$(update_tail ${SNAKE[*]})
			if [ $? -ne 0 ]; then
				unset SNAKE[$TAIL]
			else
				SNAKE[$TAIL]="$NEW_TAIL"
			fi
		fi
		SNAKE[$HEAD]="$NEW_HEAD"
	fi

	##print snake
	if [ "$OLD_TAIL" != "" ]; then
		tputxy " " $OLD_TAIL
	fi
	tputxy "#" $NEW_HEAD
done

######################### unset custom terminal config #########################

setterm -cursor on	#make the cursor reappear
stty echo #make input characters reappear

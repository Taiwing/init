#!/bin/bash

############################ set terminal config ###############################

stty -echo # make input characters desappear
tput civis # make the cursor disappear

############################# signal handling ##################################

function exit_snake()
{
	tput clear
	echo "snake: exiting..."
	tput cnorm
	stty echo
	exit 1
}

# TODO: uncomment this when the script is finished
#SIG=0
#while [ $SIG -lt 30 ]; do
#	trap "exit_snake" $SIG
#	((SIG++))
#done

################################### utils ######################################

function getxy()
{
	local X=$(echo $1 | cut -d_ -f1)
	local Y=$(echo $1 | cut -d_ -f2)
	echo "$X $Y"
}

######################### random coordinate generator ##########################

function rand_coord()
{
	return $((RANDOM%$1))
}

################################### tmove ######################################

function tputxy()
{
	local Y=$3
	local X=$2
	((Y++))
	((X++))
	echo -en "\033[${Y};${X}H${1}"
}

################################### move_head ##################################

function move_head() 
{
	local HEAD="$1"
	local DIRECTION=$2
	local S_X=$(echo $HEAD | cut -d_ -f1)
	local S_Y=$(echo $HEAD | cut -d_ -f2)
	case $DIRECTION in
		$UP)	((S_Y--));;
		$DOWN)	((S_Y++));;
		$LEFT)	((S_X--));;
		$RIGHT)	((S_X++));;
	esac
	echo "${S_X}_${S_Y}"
}

################################## move_tail ###################################

function move_tail()
{
	#get current tail
	local TAIL_X=$(echo $1 | cut -d_ -f1)
	local TAIL_Y=$(echo $1 | cut -d_ -f2)
	#get next block
	local NEXT_X=$(echo $2 | cut -d_ -f1)
	local NEXT_Y=$(echo $2 | cut -d_ -f2)
	#get the direction
	local DIFF_X=$((NEXT_X-TAIL_X))
	local DIFF_Y=$((NEXT_Y-TAIL_Y))

	if [ $DIFF_X -eq 0 ]; then
		Y=$TAIL_Y
		if [ $DIFF_Y -lt 0 ]; then
			((Y--))
		elif [ $DIFF_Y -gt 0 ]; then
			((Y++))
		fi
		echo "${TAIL_X}_${Y}"
	elif [ $DIFF_Y -eq 0 ]; then
		X=$TAIL_X
		if [ $DIFF_X -lt 0 ]; then
			((X--))
		elif [ $DIFF_X -gt 0 ]; then
			((X++))
		fi
		echo "${X}_${TAIL_Y}"
	fi
	#return new coordinates for current tail
}

################################# collide_test #################################

##compare the snake coordinates to X and Y
function collide_test()
{
	local X=$(echo $1 | cut -d_ -f1)
	local Y=$(echo $1 | cut -d_ -f2)
	local X_Y="$X $Y"
	shift

	local CUR=""
	local PREV=""
	local C_X=0
	local C_Y=0
	local P_X=0
	local P_Y=0
	while [ "$1" != "" ]; do
		CUR=$(getxy $1)
		if [ "$CUR" == "$X_Y" ]; then
			return 1
		elif [ "$PREV" != "" ]; then
			C_X=$(echo $CUR | cut -d\  -f1)
			C_Y=$(echo $CUR | cut -d\  -f2)
			P_X=$(echo $PREV | cut -d\  -f1)
			P_Y=$(echo $PREV | cut -d\  -f2)
			if [ $X == $C_X -a $C_X == $P_X ]; then
				if [ $C_Y -lt $P_Y ] && \
				(( Y >= C_Y && Y <= P_Y )); then
					return 1;
				elif [ $P_Y -lt $C_Y ] && \
				(( Y >= P_Y && Y <= C_Y )); then
					return 1;
				fi
			elif [ $Y == $C_Y -a $C_Y == $P_Y ]; then
				if [ $C_X -lt $P_X ] && \
				(( X >= C_X && X <= P_X )); then
					return 1;
				elif [ $P_X -lt $C_X ] && \
				(( X >= P_X && X <= C_X )); then
					return 1;
				fi
			fi
		fi
		PREV="$CUR"
		shift
	done
	return 0
}

############################# wall_collide_test ################################

function wall_collide_test()
{
	local X=$(echo $1 | cut -d_ -f1)
	local Y=$(echo $1 | cut -d_ -f2)
	local C=$2
	local L=$3

	if [ $X -eq -1 -o $Y -eq -1 -o $X -eq $C -o $Y -eq $L ]; then
		return 1
	fi
	return 0
}

######################### print_game_over_screen ###############################

function print_game_over_screen()
{
	local C=$1
	local L=$2
	local SCORE=$(printf "%07d" $3)
	tputxy "                    " $((C/2-10)) $((L/2-6))
	tputxy "     GAME OVER      " $((C/2-10)) $((L/2-5))
	tputxy "                    " $((C/2-10)) $((L/2-4))
	tputxy "   Score: $SCORE   " $((C/2-10)) $((L/2-3))
	tputxy "                    " $((C/2-10)) $((L/2-2))
	tputxy " press 'q' to leave " $((C/2-10)) $((L/2-1))
	tputxy "                     \n" $((C/2-10)) $((L/2))
	local INPUT=""
	while [ "$INPUT" != "q" ]; do
		read -sn1 INPUT
	done
	tput clear
}

########################### get terminal dimensions ############################

tput clear
tput cols > tmp
read COLS < tmp
tput lines > tmp
read LINES < tmp
rm tmp

############################# set game variables ###############################

UP=-2
DOWN=-1
LEFT=1
RIGHT=2
DIR=0

HEAD=0
TAIL=0
NEXT=1
declare -a SNAKE
rand_coord $COLS
SNAKE+=("$?")
rand_coord $LINES
SNAKE[$HEAD]="${SNAKE[$HEAD]}_${?}"
LENGTH=1
ADD_BLOCKS=0

CHERRY="${SNAKE[$HEAD]}"
while [ "$CHERRY" == "${SNAKE[$HEAD]}" ]; do
	rand_coord $COLS
	CHERRY="$?"
	rand_coord $LINES
	CHERRY="${CHERRY}_${?}"
done

################################# initiate game ################################

tputxy "#" $(getxy ${SNAKE[$HEAD]})
tputxy "*" $(getxy $CHERRY)

INPUT=""
escape_char=$(printf "\033")
while [ $DIR -eq 0 ]; do
	read -sn3 INPUT # get 3 charaters
	case $INPUT in
		"$escape_char[A") DIR=$UP 		;;
		"$escape_char[B") DIR=$DOWN 	;;
		"$escape_char[D") DIR=$LEFT 	;;
		"$escape_char[C") DIR=$RIGHT	;;
	esac
done
OLDIR=$DIR

################################## input loop ##################################

while [ 42 ]; do
	##get input
	DIR_INPUT=$DIR
	read -sn3 -t 0.03 INPUT # get 3 characters at most
	if [ "${INPUT:0:1}" == "$escape_char" -a  ${#INPUT} -ge 3 ]; then
		case ${INPUT:1:2} in
			'[A') DIR_INPUT=$UP 	;;
			'[B') DIR_INPUT=$DOWN 	;;
			'[D') DIR_INPUT=$LEFT 	;;
			'[C') DIR_INPUT=$RIGHT	;;
		esac
	elif [ "${INPUT:0:1}" == "q" ]; then
		tput clear
		break
	elif [ "${INPUT:0:1}" == "p" ]; then
		P_X=$((COLS/2))
		((P_X-=3))
		tputxy "PAUSE" $P_X 0
		INPUT=""
		while [ "$INPUT" != "p" -a "$INPUT" != "q" ]; do
			read -sn1 INPUT
		done
		tputxy "     " $P_X 0
		if [ "$INPUT" == "q" ]; then
			tput clear
			break
		fi
	fi

	##set direction
	OLDIR=$DIR
	if [ $DIR -lt 0 -a $DIR_INPUT -gt 0 ]; then
		DIR=$DIR_INPUT
	elif [ $DIR -gt 0 -a $DIR_INPUT -lt 0 ]; then
		DIR=$DIR_INPUT
	fi

	##move snake and check CHERRY position
	OLD_HEAD="${SNAKE[$HEAD]}"
	NEW_HEAD=$(move_head "${SNAKE[$HEAD]}" $DIR)
	if [ "$NEW_HEAD" == "$CHERRY" ]; then
		((ADD_BLOCKS+=4))
		COLLIDE=1
		while [ $COLLIDE != 0 ]; do
			rand_coord $COLS
			CHERRY="$?"
			rand_coord $LINES
			CHERRY="${CHERRY}_${?}"
			collide_test "$CHERRY" ${SNAKE[*]} "$NEW_HEAD"
			COLLIDE=$?
		done
		tputxy "*" $(getxy $CHERRY)
	fi

	##add blocks or move tail
	OLD_TAIL="${SNAKE[$TAIL]}"
	if [ $ADD_BLOCKS -ne 0 ]; then
		if [ $HEAD -eq $TAIL -o $DIR -ne $OLDIR ]; then
			SNAKE+=("$NEW_HEAD")
			((HEAD++))
		else
			SNAKE[$HEAD]="$NEW_HEAD"
		fi
		((ADD_BLOCKS--))
		((LENGTH++))
		OLD_TAIL=""
	else
		if [ $DIR -ne $OLDIR ]; then
			SNAKE+=("$NEW_HEAD")
			((HEAD++))
		else
			SNAKE[$HEAD]="$NEW_HEAD"
		fi
		if [ $HEAD -ne $TAIL ]; then
			NEW_TAIL=$(move_tail "${SNAKE[$TAIL]}" \
				"${SNAKE[$NEXT]}")
			if [ "$NEW_TAIL" == "${SNAKE[$NEXT]}" ]; then
				COPY=(${SNAKE[*]:1})
				unset SNAKE
				SNAKE=(${COPY[*]})
				unset COPY
				((HEAD--))
			else
				SNAKE[$TAIL]="$NEW_TAIL"
			fi
		fi
	fi
	
	##check snake collision with itself
	wall_collide_test "$NEW_HEAD" $COLS $LINES
	COLLIDE=$?
	if [ $COLLIDE -eq 0 ]; then
		collide_test "$NEW_HEAD" ${SNAKE[*]:0:$HEAD} "$OLD_HEAD"
		COLLIDE=$?
	fi
	if [ $COLLIDE -ne 0 ]; then
		print_game_over_screen $COLS $LINES $LENGTH
		break
	fi

	##print snake
	if [ "$OLD_TAIL" != "" ]; then
		tputxy " " $(getxy $OLD_TAIL)
	fi
	tputxy "#" $(getxy $NEW_HEAD)

	#DEBUG
	tputxy "                             \n" 0 0
	tputxy "                             \n" 0 1
	tputxy "                             \n" 0 2
	tputxy "                             \n" 0 3
	tputxy "LENGTH=${LENGTH}\n" 0 0
	echo "TAIL=$TAIL -- HEAD=$HEAD"
	echo "SNAKE[TAIL]='$(getxy ${SNAKE[$TAIL]})'"
	echo "SNAKE[HEAD]='$(getxy ${SNAKE[$HEAD]})'"
	echo "CHERRY='$(getxy $CHERRY)'"
	#DEBUG
done

######################### unset custom terminal config #########################

tput cnorm #make the cursor reappear
stty echo #make input characters reappear
